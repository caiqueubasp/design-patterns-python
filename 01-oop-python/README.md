/**
* This class demonstrates the principles of Object-Oriented Programming (OOP).
* 
* Object-Oriented Programming is a programming paradigm based on the concept of "objects",
* which can contain data, in the form of fields (often known as attributes or properties),
* and code, in the form of procedures (often known as methods).
* 
* The four main principles of OOP are:
* 
* 1. **Encapsulation**: Bundling the data (attributes) and the methods (functions) that operate on the data into a single unit or class, and restricting access to some of the object's components.
* 
* 2. **Abstraction**: Hiding the complex implementation details and showing only the necessary features of the object. This helps in reducing programming complexity and effort.
* 
* 3. **Inheritance**: Mechanism where a new class inherits the properties and behavior (methods) of another class. It promotes code reusability and establishes a natural hierarchy between classes.
* 
* 4. **Polymorphism**: Ability of different classes to be treated as instances of the same class through a common interface. It allows methods to do different things based on the object it is acting upon, even though they share the same name.
* 
* These principles help in creating modular, reusable, and maintainable code.
 

## SOLID Principles

The SOLID principles are a set of five design principles intended to make software designs more understandable, flexible, and maintainable. These principles are:

1. **Single Responsibility Principle (SRP)**: A class should have only one reason to change, meaning it should only have one job or responsibility.

2. **Open/Closed Principle (OCP)**: Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code.

3. **Liskov Substitution Principle (LSP)**: Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. This ensures that a subclass can stand in for its superclass.

4. **Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they do not use. This means creating smaller, more specific interfaces rather than a large, general-purpose one.

5. **Dependency Inversion Principle (DIP)**: High-level modules should not depend on low-level modules. Both should depend on abstractions. Additionally, abstractions should not depend on details. Details should depend on abstractions.

Adhering to these principles helps in building robust and scalable software systems.